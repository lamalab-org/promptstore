{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PromptStore","text":"<p>A lightweight Python package for managing and versioning LLM prompt templates.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple JSON-based storage</li> <li>Template versioning</li> <li>Tag-based organization</li> <li>Jinja2 template support</li> <li>Package integration utilities</li> <li>Easy to extend and customize</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from promptstore import PromptStore\n\n# Create a new store\nstore = PromptStore(\"./prompts\")\n\n# Add a prompt template\nprompt = store.add(\n    content=\"Write a {{language}} function that {{task}}\",\n    description=\"Code generation prompt\",\n    tags=[\"coding\", \"generation\"]\n)\n\n# Use the prompt\nfilled = prompt.fill({\n    \"language\": \"Python\",\n    \"task\": \"sorts a list in reverse order\"\n})\n</code></pre>"},{"location":"#why-promptstore","title":"Why PromptStore?","text":"<ul> <li>Lightweight: Minimal dependencies, just Jinja2</li> <li>Simple: JSON-based storage, easy to inspect and modify</li> <li>Flexible: Support for both local development and package distribution</li> <li>Versioned: Track changes to your prompts</li> <li>Organized: Tag and search your prompts</li> <li>Package-Ready: Easy to bundle prompts with your package</li> </ul>"},{"location":"api/","title":"API Docs","text":""},{"location":"api/#promptstore","title":"PromptStore","text":""},{"location":"api/#promptstore.store.PromptStore","title":"<code>promptstore.store.PromptStore</code>","text":"Source code in <code>src/promptstore/store.py</code> <pre><code>class PromptStore:\n    def __init__(self, location: Union[str, Path], readonly: bool = False):\n        \"\"\"Initialize a new PromptStore.\n\n        Args:\n            location: Path to the directory where prompts will be stored\n            readonly: If True, the store will be read-only\n        \"\"\"\n        self.location = Path(location)\n        self.readonly = readonly\n        self.index_path = self.location / \"index.json\"\n        self._init_storage()\n\n    def _init_storage(self):\n        \"\"\"Initialize the storage directory and index.\"\"\"\n        self.location.mkdir(parents=True, exist_ok=True)\n\n        if not self.index_path.exists() and not self.readonly:\n            self._save_index({})\n\n    def _load_index(self) -&gt; Dict:\n        \"\"\"Load the prompt index.\"\"\"\n        if not self.index_path.exists():\n            return {}\n        with open(self.index_path, \"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n\n    def _save_index(self, index: Dict):\n        \"\"\"Save the prompt index.\"\"\"\n        if self.readonly:\n            raise ReadOnlyStoreError(\"Cannot modify a read-only prompt store\")\n        with open(self.index_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(index, f, indent=2, ensure_ascii=False)\n\n    @classmethod\n    def from_dict(cls, prompts: Dict, readonly: bool = True) -&gt; \"PromptStore\":\n        \"\"\"Create a PromptStore from a dictionary.\n\n        Args:\n            prompts: Dictionary of prompt data\n            readonly: If True, the store will be read-only\n\n        Returns:\n            PromptStore: A prompt store initialized with the given prompts\n        \"\"\"\n        import tempfile\n\n        temp_dir = Path(tempfile.mkdtemp())\n        store = cls(temp_dir, readonly=readonly)\n\n        with open(store.index_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(prompts, f, indent=2, ensure_ascii=False)\n\n        return store\n\n    @classmethod\n    def from_file(cls, path: Union[str, Path], readonly: bool = True) -&gt; \"PromptStore\":\n        \"\"\"Create a PromptStore from a JSON file.\n\n        Args:\n            path: Path to the JSON file containing prompts\n            readonly: If True, the store will be read-only\n\n        Returns:\n            PromptStore: A prompt store initialized with the prompts from the file\n        \"\"\"\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"Prompt file not found: {path}\")\n\n        if path.is_file():\n            # If it's a single JSON file\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                prompts = json.load(f)\n        else:\n            # If it's a directory containing an index.json\n            index_path = path / \"index.json\"\n            if not index_path.exists():\n                raise FileNotFoundError(f\"No index.json found in directory: {path}\")\n            with open(index_path, \"r\", encoding=\"utf-8\") as f:\n                prompts = json.load(f)\n\n        return cls.from_dict(prompts, readonly=readonly)\n\n    def add(\n        self,\n        content: str,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n    ) -&gt; Prompt:\n        \"\"\"Add a new prompt to the store.\n\n        Args:\n            content: The content of the prompt\n            description: A description of the prompt\n            tags: A list of tags for the prompt\n\n        Returns:\n            Prompt: The newly created prompt\n        \"\"\"\n        if self.readonly:\n            raise ReadOnlyStoreError(\"Cannot modify a read-only prompt store\")\n\n        prompt_uuid = str(uuid.uuid4())\n        now = datetime.utcnow().isoformat()\n\n        prompt_data = {\n            \"uuid\": prompt_uuid,\n            \"content\": content,\n            \"description\": description,\n            \"version\": 1,\n            \"versions\": [\n                {\n                    \"content\": content,\n                    \"description\": description,\n                    \"version\": 1,\n                    \"created_at\": now,\n                }\n            ],\n            \"tags\": tags or [],\n            \"created_at\": now,\n            \"updated_at\": now,\n        }\n\n        index = self._load_index()\n        index[prompt_uuid] = prompt_data\n        self._save_index(index)\n\n        return Prompt(\n            uuid=prompt_uuid,\n            content=content,\n            description=description,\n            version=1,\n            tags=tags or [],\n            timestamp=now,\n        )\n\n    def get(self, uuid: str, version: Optional[int] = None) -&gt; Prompt:\n        \"\"\"Retrieve a prompt by its UUID.\n\n        Args:\n            uuid: The UUID of the prompt to retrieve\n            version: The version of the prompt to retrieve\n\n        Returns:\n            Prompt: The prompt object\n        \"\"\"\n        index = self._load_index()\n        if uuid not in index:\n            raise PromptNotFoundError(f\"Prompt with UUID {uuid} not found\")\n\n        prompt_data = index[uuid]\n\n        if version:\n            version_data = next(\n                (v for v in prompt_data[\"versions\"] if v[\"version\"] == version), None\n            )\n            if not version_data:\n                raise PromptNotFoundError(\n                    f\"Version {version} of prompt {uuid} not found\"\n                )\n            content = version_data[\"content\"]\n            description = version_data[\"description\"]\n            timestamp = version_data[\"created_at\"]\n        else:\n            content = prompt_data[\"content\"]\n            description = prompt_data[\"description\"]\n            timestamp = prompt_data[\"updated_at\"]\n\n        return Prompt(\n            uuid=uuid,\n            content=content,\n            description=description,\n            version=prompt_data[\"version\"],\n            tags=prompt_data[\"tags\"],\n            timestamp=timestamp,\n        )\n\n    def find(self, query: str, field: str = \"description\") -&gt; List[Prompt]:\n        \"\"\"Search for prompts based on a query.\n\n        Args:\n            query: The search query\n            field: The field to search in (description, content, or tags)\n\n        Returns:\n            List[Prompt]: A list of prompts matching the query\n        \"\"\"\n        if field not in (\"description\", \"content\", \"tags\"):\n            raise ValueError(\"Field must be 'description', 'content', or 'tags'\")\n\n        index = self._load_index()\n        prompts = []\n\n        for uuid_, data in index.items():\n            if field == \"tags\":\n                if any(query.lower() in tag.lower() for tag in data[\"tags\"]):\n                    prompts.append(self._data_to_prompt(uuid_, data))\n            else:\n                value = data.get(field, \"\")\n                if value and query.lower() in value.lower():\n                    prompts.append(self._data_to_prompt(uuid_, data))\n\n        return prompts\n\n    def _data_to_prompt(self, uuid: str, data: Dict) -&gt; Prompt:\n        \"\"\"Convert raw data to a Prompt object.\n\n        Args:\n            uuid: The UUID of the prompt\n            data: The raw data for the prompt\n\n        Returns:\n            Prompt: The prompt object\n        \"\"\"\n        return Prompt(\n            uuid=uuid,\n            content=data[\"content\"],\n            description=data[\"description\"],\n            version=data[\"version\"],\n            tags=data[\"tags\"],\n            timestamp=data[\"updated_at\"],\n        )\n\n    def merge(self, other: \"PromptStore\", override: bool = False):\n        \"\"\"Merge another PromptStore into this one.\n\n        Args:\n            other: The other PromptStore to merge\n            override: If True, override existing prompts with those from the other store\n\n        Raises:\n            ReadOnlyStoreError: If the store is read-only\n        \"\"\"\n        if self.readonly:\n            raise ReadOnlyStoreError(\"Cannot modify a read-only prompt store\")\n\n        our_index = self._load_index()\n        their_index = other._load_index()\n\n        for uuid_, their_data in their_index.items():\n            if uuid not in our_index or override:\n                our_index[uuid_] = their_data\n\n        self._save_index(our_index)\n\n    def __iter__(self) -&gt; Iterator[Prompt]:\n        \"\"\"Iterate over all prompts in the store.\"\"\"\n        index = self._load_index()\n        for uuid_, data in index.items():\n            yield self._data_to_prompt(uuid_, data)\n\n    def update(\n        self,\n        uuid: str,\n        content: str,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n    ) -&gt; Prompt:\n        \"\"\"Update an existing prompt with a new version.\n\n        Args:\n            uuid: The UUID of the prompt to update\n            content: New content for the prompt\n            description: New description for the prompt\n            tags: New tags for the prompt\n\n        Returns:\n            Prompt: The updated prompt\n\n        Raises:\n            ReadOnlyStoreError: If the store is read-only\n            PromptNotFoundError: If the prompt with the given UUID doesn't exist\n        \"\"\"\n        if self.readonly:\n            raise ReadOnlyStoreError(\"Cannot modify a read-only prompt store\")\n\n        index = self._load_index()\n        if uuid not in index:\n            raise PromptNotFoundError(f\"Prompt with UUID {uuid} not found\")\n\n        prompt_data = index[uuid]\n        now = datetime.utcnow().isoformat()\n\n        new_version = prompt_data[\"version\"] + 1\n\n        prompt_data[\"versions\"].append(\n            {\n                \"content\": content,\n                \"description\": description\n                if description is not None\n                else prompt_data[\"description\"],\n                \"version\": new_version,\n                \"created_at\": now,\n            }\n        )\n\n        prompt_data[\"content\"] = content\n        if description is not None:\n            prompt_data[\"description\"] = description\n        if tags is not None:\n            prompt_data[\"tags\"] = tags\n        prompt_data[\"version\"] = new_version\n        prompt_data[\"updated_at\"] = now\n\n        self._save_index(index)\n\n        return Prompt(\n            uuid=uuid,\n            content=content,\n            description=description\n            if description is not None\n            else prompt_data[\"description\"],\n            version=new_version,\n            tags=tags if tags is not None else prompt_data[\"tags\"],\n            timestamp=now,\n        )\n\n    def get_online(\n        self, uuid: str, url: str, version: int | None = None, folder: str = \"prompts\"\n    ) -&gt; Prompt:\n        \"\"\"Retrieve a prompt by its UUID from an online store.\n\n        Args:\n            uuid: The UUID of the prompt to retrieve\n            url: The URL of the online store\n            version: The version of the prompt to retrieve\n            folder: The folder name to use for caching (defaults to \"prompts\")\n\n        Returns:\n            Prompt: The prompt object\n\n        Raises:\n            PromptNotFoundError: If the prompt with the given UUID doesn't exist\n        \"\"\"\n        data = pystow.ensure_json(folder, url=url)\n\n        if uuid not in data:\n            raise PromptNotFoundError(\n                f\"Prompt with UUID {uuid} not found in online store\"\n            )\n\n        prompt_data = data[uuid]\n\n        if version:\n            version_data = next(\n                (v for v in prompt_data[\"versions\"] if v[\"version\"] == version), None\n            )\n            if not version_data:\n                raise PromptNotFoundError(\n                    f\"Version {version} of prompt {uuid} not found in online store\"\n                )\n            content = version_data[\"content\"]\n            description = version_data[\"description\"]\n            timestamp = version_data[\"created_at\"]\n        else:\n            content = prompt_data[\"content\"]\n            description = prompt_data[\"description\"]\n            timestamp = prompt_data[\"updated_at\"]\n\n        return Prompt(\n            uuid=uuid,\n            content=content,\n            description=description,\n            version=prompt_data[\"version\"],\n            tags=prompt_data[\"tags\"],\n            timestamp=timestamp,\n        )\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.__init__","title":"<code>__init__(location, readonly=False)</code>","text":"<p>Initialize a new PromptStore.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Union[str, Path]</code> <p>Path to the directory where prompts will be stored</p> required <code>readonly</code> <code>bool</code> <p>If True, the store will be read-only</p> <code>False</code> Source code in <code>src/promptstore/store.py</code> <pre><code>def __init__(self, location: Union[str, Path], readonly: bool = False):\n    \"\"\"Initialize a new PromptStore.\n\n    Args:\n        location: Path to the directory where prompts will be stored\n        readonly: If True, the store will be read-only\n    \"\"\"\n    self.location = Path(location)\n    self.readonly = readonly\n    self.index_path = self.location / \"index.json\"\n    self._init_storage()\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all prompts in the store.</p> Source code in <code>src/promptstore/store.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Prompt]:\n    \"\"\"Iterate over all prompts in the store.\"\"\"\n    index = self._load_index()\n    for uuid_, data in index.items():\n        yield self._data_to_prompt(uuid_, data)\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.add","title":"<code>add(content, description=None, tags=None)</code>","text":"<p>Add a new prompt to the store.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content of the prompt</p> required <code>description</code> <code>Optional[str]</code> <p>A description of the prompt</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>A list of tags for the prompt</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Prompt</code> <code>Prompt</code> <p>The newly created prompt</p> Source code in <code>src/promptstore/store.py</code> <pre><code>def add(\n    self,\n    content: str,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n) -&gt; Prompt:\n    \"\"\"Add a new prompt to the store.\n\n    Args:\n        content: The content of the prompt\n        description: A description of the prompt\n        tags: A list of tags for the prompt\n\n    Returns:\n        Prompt: The newly created prompt\n    \"\"\"\n    if self.readonly:\n        raise ReadOnlyStoreError(\"Cannot modify a read-only prompt store\")\n\n    prompt_uuid = str(uuid.uuid4())\n    now = datetime.utcnow().isoformat()\n\n    prompt_data = {\n        \"uuid\": prompt_uuid,\n        \"content\": content,\n        \"description\": description,\n        \"version\": 1,\n        \"versions\": [\n            {\n                \"content\": content,\n                \"description\": description,\n                \"version\": 1,\n                \"created_at\": now,\n            }\n        ],\n        \"tags\": tags or [],\n        \"created_at\": now,\n        \"updated_at\": now,\n    }\n\n    index = self._load_index()\n    index[prompt_uuid] = prompt_data\n    self._save_index(index)\n\n    return Prompt(\n        uuid=prompt_uuid,\n        content=content,\n        description=description,\n        version=1,\n        tags=tags or [],\n        timestamp=now,\n    )\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.find","title":"<code>find(query, field='description')</code>","text":"<p>Search for prompts based on a query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query</p> required <code>field</code> <code>str</code> <p>The field to search in (description, content, or tags)</p> <code>'description'</code> <p>Returns:</p> Type Description <code>List[Prompt]</code> <p>List[Prompt]: A list of prompts matching the query</p> Source code in <code>src/promptstore/store.py</code> <pre><code>def find(self, query: str, field: str = \"description\") -&gt; List[Prompt]:\n    \"\"\"Search for prompts based on a query.\n\n    Args:\n        query: The search query\n        field: The field to search in (description, content, or tags)\n\n    Returns:\n        List[Prompt]: A list of prompts matching the query\n    \"\"\"\n    if field not in (\"description\", \"content\", \"tags\"):\n        raise ValueError(\"Field must be 'description', 'content', or 'tags'\")\n\n    index = self._load_index()\n    prompts = []\n\n    for uuid_, data in index.items():\n        if field == \"tags\":\n            if any(query.lower() in tag.lower() for tag in data[\"tags\"]):\n                prompts.append(self._data_to_prompt(uuid_, data))\n        else:\n            value = data.get(field, \"\")\n            if value and query.lower() in value.lower():\n                prompts.append(self._data_to_prompt(uuid_, data))\n\n    return prompts\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.from_dict","title":"<code>from_dict(prompts, readonly=True)</code>  <code>classmethod</code>","text":"<p>Create a PromptStore from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <code>Dict</code> <p>Dictionary of prompt data</p> required <code>readonly</code> <code>bool</code> <p>If True, the store will be read-only</p> <code>True</code> <p>Returns:</p> Name Type Description <code>PromptStore</code> <code>PromptStore</code> <p>A prompt store initialized with the given prompts</p> Source code in <code>src/promptstore/store.py</code> <pre><code>@classmethod\ndef from_dict(cls, prompts: Dict, readonly: bool = True) -&gt; \"PromptStore\":\n    \"\"\"Create a PromptStore from a dictionary.\n\n    Args:\n        prompts: Dictionary of prompt data\n        readonly: If True, the store will be read-only\n\n    Returns:\n        PromptStore: A prompt store initialized with the given prompts\n    \"\"\"\n    import tempfile\n\n    temp_dir = Path(tempfile.mkdtemp())\n    store = cls(temp_dir, readonly=readonly)\n\n    with open(store.index_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(prompts, f, indent=2, ensure_ascii=False)\n\n    return store\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.from_file","title":"<code>from_file(path, readonly=True)</code>  <code>classmethod</code>","text":"<p>Create a PromptStore from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the JSON file containing prompts</p> required <code>readonly</code> <code>bool</code> <p>If True, the store will be read-only</p> <code>True</code> <p>Returns:</p> Name Type Description <code>PromptStore</code> <code>PromptStore</code> <p>A prompt store initialized with the prompts from the file</p> Source code in <code>src/promptstore/store.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Union[str, Path], readonly: bool = True) -&gt; \"PromptStore\":\n    \"\"\"Create a PromptStore from a JSON file.\n\n    Args:\n        path: Path to the JSON file containing prompts\n        readonly: If True, the store will be read-only\n\n    Returns:\n        PromptStore: A prompt store initialized with the prompts from the file\n    \"\"\"\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"Prompt file not found: {path}\")\n\n    if path.is_file():\n        # If it's a single JSON file\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            prompts = json.load(f)\n    else:\n        # If it's a directory containing an index.json\n        index_path = path / \"index.json\"\n        if not index_path.exists():\n            raise FileNotFoundError(f\"No index.json found in directory: {path}\")\n        with open(index_path, \"r\", encoding=\"utf-8\") as f:\n            prompts = json.load(f)\n\n    return cls.from_dict(prompts, readonly=readonly)\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.get","title":"<code>get(uuid, version=None)</code>","text":"<p>Retrieve a prompt by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The UUID of the prompt to retrieve</p> required <code>version</code> <code>Optional[int]</code> <p>The version of the prompt to retrieve</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Prompt</code> <code>Prompt</code> <p>The prompt object</p> Source code in <code>src/promptstore/store.py</code> <pre><code>def get(self, uuid: str, version: Optional[int] = None) -&gt; Prompt:\n    \"\"\"Retrieve a prompt by its UUID.\n\n    Args:\n        uuid: The UUID of the prompt to retrieve\n        version: The version of the prompt to retrieve\n\n    Returns:\n        Prompt: The prompt object\n    \"\"\"\n    index = self._load_index()\n    if uuid not in index:\n        raise PromptNotFoundError(f\"Prompt with UUID {uuid} not found\")\n\n    prompt_data = index[uuid]\n\n    if version:\n        version_data = next(\n            (v for v in prompt_data[\"versions\"] if v[\"version\"] == version), None\n        )\n        if not version_data:\n            raise PromptNotFoundError(\n                f\"Version {version} of prompt {uuid} not found\"\n            )\n        content = version_data[\"content\"]\n        description = version_data[\"description\"]\n        timestamp = version_data[\"created_at\"]\n    else:\n        content = prompt_data[\"content\"]\n        description = prompt_data[\"description\"]\n        timestamp = prompt_data[\"updated_at\"]\n\n    return Prompt(\n        uuid=uuid,\n        content=content,\n        description=description,\n        version=prompt_data[\"version\"],\n        tags=prompt_data[\"tags\"],\n        timestamp=timestamp,\n    )\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.get_online","title":"<code>get_online(uuid, url, version=None, folder='prompts')</code>","text":"<p>Retrieve a prompt by its UUID from an online store.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The UUID of the prompt to retrieve</p> required <code>url</code> <code>str</code> <p>The URL of the online store</p> required <code>version</code> <code>int | None</code> <p>The version of the prompt to retrieve</p> <code>None</code> <code>folder</code> <code>str</code> <p>The folder name to use for caching (defaults to \"prompts\")</p> <code>'prompts'</code> <p>Returns:</p> Name Type Description <code>Prompt</code> <code>Prompt</code> <p>The prompt object</p> <p>Raises:</p> Type Description <code>PromptNotFoundError</code> <p>If the prompt with the given UUID doesn't exist</p> Source code in <code>src/promptstore/store.py</code> <pre><code>def get_online(\n    self, uuid: str, url: str, version: int | None = None, folder: str = \"prompts\"\n) -&gt; Prompt:\n    \"\"\"Retrieve a prompt by its UUID from an online store.\n\n    Args:\n        uuid: The UUID of the prompt to retrieve\n        url: The URL of the online store\n        version: The version of the prompt to retrieve\n        folder: The folder name to use for caching (defaults to \"prompts\")\n\n    Returns:\n        Prompt: The prompt object\n\n    Raises:\n        PromptNotFoundError: If the prompt with the given UUID doesn't exist\n    \"\"\"\n    data = pystow.ensure_json(folder, url=url)\n\n    if uuid not in data:\n        raise PromptNotFoundError(\n            f\"Prompt with UUID {uuid} not found in online store\"\n        )\n\n    prompt_data = data[uuid]\n\n    if version:\n        version_data = next(\n            (v for v in prompt_data[\"versions\"] if v[\"version\"] == version), None\n        )\n        if not version_data:\n            raise PromptNotFoundError(\n                f\"Version {version} of prompt {uuid} not found in online store\"\n            )\n        content = version_data[\"content\"]\n        description = version_data[\"description\"]\n        timestamp = version_data[\"created_at\"]\n    else:\n        content = prompt_data[\"content\"]\n        description = prompt_data[\"description\"]\n        timestamp = prompt_data[\"updated_at\"]\n\n    return Prompt(\n        uuid=uuid,\n        content=content,\n        description=description,\n        version=prompt_data[\"version\"],\n        tags=prompt_data[\"tags\"],\n        timestamp=timestamp,\n    )\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.merge","title":"<code>merge(other, override=False)</code>","text":"<p>Merge another PromptStore into this one.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PromptStore</code> <p>The other PromptStore to merge</p> required <code>override</code> <code>bool</code> <p>If True, override existing prompts with those from the other store</p> <code>False</code> <p>Raises:</p> Type Description <code>ReadOnlyStoreError</code> <p>If the store is read-only</p> Source code in <code>src/promptstore/store.py</code> <pre><code>def merge(self, other: \"PromptStore\", override: bool = False):\n    \"\"\"Merge another PromptStore into this one.\n\n    Args:\n        other: The other PromptStore to merge\n        override: If True, override existing prompts with those from the other store\n\n    Raises:\n        ReadOnlyStoreError: If the store is read-only\n    \"\"\"\n    if self.readonly:\n        raise ReadOnlyStoreError(\"Cannot modify a read-only prompt store\")\n\n    our_index = self._load_index()\n    their_index = other._load_index()\n\n    for uuid_, their_data in their_index.items():\n        if uuid not in our_index or override:\n            our_index[uuid_] = their_data\n\n    self._save_index(our_index)\n</code></pre>"},{"location":"api/#promptstore.store.PromptStore.update","title":"<code>update(uuid, content, description=None, tags=None)</code>","text":"<p>Update an existing prompt with a new version.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The UUID of the prompt to update</p> required <code>content</code> <code>str</code> <p>New content for the prompt</p> required <code>description</code> <code>Optional[str]</code> <p>New description for the prompt</p> <code>None</code> <code>tags</code> <code>Optional[List[str]]</code> <p>New tags for the prompt</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Prompt</code> <code>Prompt</code> <p>The updated prompt</p> <p>Raises:</p> Type Description <code>ReadOnlyStoreError</code> <p>If the store is read-only</p> <code>PromptNotFoundError</code> <p>If the prompt with the given UUID doesn't exist</p> Source code in <code>src/promptstore/store.py</code> <pre><code>def update(\n    self,\n    uuid: str,\n    content: str,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n) -&gt; Prompt:\n    \"\"\"Update an existing prompt with a new version.\n\n    Args:\n        uuid: The UUID of the prompt to update\n        content: New content for the prompt\n        description: New description for the prompt\n        tags: New tags for the prompt\n\n    Returns:\n        Prompt: The updated prompt\n\n    Raises:\n        ReadOnlyStoreError: If the store is read-only\n        PromptNotFoundError: If the prompt with the given UUID doesn't exist\n    \"\"\"\n    if self.readonly:\n        raise ReadOnlyStoreError(\"Cannot modify a read-only prompt store\")\n\n    index = self._load_index()\n    if uuid not in index:\n        raise PromptNotFoundError(f\"Prompt with UUID {uuid} not found\")\n\n    prompt_data = index[uuid]\n    now = datetime.utcnow().isoformat()\n\n    new_version = prompt_data[\"version\"] + 1\n\n    prompt_data[\"versions\"].append(\n        {\n            \"content\": content,\n            \"description\": description\n            if description is not None\n            else prompt_data[\"description\"],\n            \"version\": new_version,\n            \"created_at\": now,\n        }\n    )\n\n    prompt_data[\"content\"] = content\n    if description is not None:\n        prompt_data[\"description\"] = description\n    if tags is not None:\n        prompt_data[\"tags\"] = tags\n    prompt_data[\"version\"] = new_version\n    prompt_data[\"updated_at\"] = now\n\n    self._save_index(index)\n\n    return Prompt(\n        uuid=uuid,\n        content=content,\n        description=description\n        if description is not None\n        else prompt_data[\"description\"],\n        version=new_version,\n        tags=tags if tags is not None else prompt_data[\"tags\"],\n        timestamp=now,\n    )\n</code></pre>"},{"location":"api/#prompt","title":"Prompt","text":""},{"location":"api/#promptstore.prompt.Prompt","title":"<code>promptstore.prompt.Prompt</code>","text":"Source code in <code>src/promptstore/prompt.py</code> <pre><code>class Prompt:\n    def __init__(\n        self,\n        uuid: str,\n        content: str,\n        version: int,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n        timestamp: Optional[str] = None,\n    ):\n        self.uuid = uuid\n        self.content = content\n        self.description = description\n        self.version = version\n        self.tags = tags or []\n        self.timestamp = timestamp\n        self._template = Template(content)\n        self.variables = self._extract_variables(content)\n\n    def fill(self, variables: dict) -&gt; str:\n        \"\"\"Fill the prompt template with provided variables.\"\"\"\n        return self._template.render(**variables)\n\n    def _extract_variables(self, content: str) -&gt; List[str]:\n        \"\"\"Extract variable names from the template content.\"\"\"\n        env = Environment()\n        ast = env.parse(content)\n        variables = meta.find_undeclared_variables(ast)\n        return sorted(list(variables))  # Convert set to sorted list\n\n    def get_variables(self) -&gt; List[str]:\n        \"\"\"Return the list of variable names in the template.\"\"\"\n        return self.variables\n</code></pre>"},{"location":"api/#promptstore.prompt.Prompt.fill","title":"<code>fill(variables)</code>","text":"<p>Fill the prompt template with provided variables.</p> Source code in <code>src/promptstore/prompt.py</code> <pre><code>def fill(self, variables: dict) -&gt; str:\n    \"\"\"Fill the prompt template with provided variables.\"\"\"\n    return self._template.render(**variables)\n</code></pre>"},{"location":"api/#promptstore.prompt.Prompt.get_variables","title":"<code>get_variables()</code>","text":"<p>Return the list of variable names in the template.</p> Source code in <code>src/promptstore/prompt.py</code> <pre><code>def get_variables(self) -&gt; List[str]:\n    \"\"\"Return the list of variable names in the template.\"\"\"\n    return self.variables\n</code></pre>"},{"location":"api/#exceptions","title":"Exceptions","text":""},{"location":"api/#promptstore.exceptions","title":"<code>promptstore.exceptions</code>","text":""},{"location":"api/#promptstore.exceptions.PromptNotFoundError","title":"<code>PromptNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a prompt with the given UUID is not found.</p> Source code in <code>src/promptstore/exceptions.py</code> <pre><code>class PromptNotFoundError(Exception):\n    \"\"\"Raised when a prompt with the given UUID is not found.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#promptstore.exceptions.ReadOnlyStoreError","title":"<code>ReadOnlyStoreError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to modify a read-only store.</p> Source code in <code>src/promptstore/exceptions.py</code> <pre><code>class ReadOnlyStoreError(Exception):\n    \"\"\"Raised when attempting to modify a read-only store.\"\"\"\n\n    pass\n</code></pre>"},{"location":"basic-usage/","title":"Basic Usage","text":""},{"location":"basic-usage/#creating-a-store","title":"Creating a Store","text":"<pre><code>from promptstore import PromptStore\n\n# Create a new store\nstore = PromptStore(\"./prompts\")\n\n# Create a read-only store\nreadonly_store = PromptStore(\"./prompts\", readonly=True)\n</code></pre>"},{"location":"basic-usage/#managing-prompts","title":"Managing Prompts","text":""},{"location":"basic-usage/#adding-prompts","title":"Adding Prompts","text":"<pre><code># Add a simple prompt\nprompt = store.add(\n    content=\"Hello, {{name}}!\",\n    description=\"Basic greeting\",\n    tags=[\"greeting\"]\n)\n\n# Add a more complex prompt\nprompt = store.add(\n    content=\"Write a {{language}} function that {{task}}\",\n    description=\"Code generation prompt\",\n    tags=[\"coding\", \"generation\"]\n)\n</code></pre>"},{"location":"basic-usage/#retrieving-prompts","title":"Retrieving Prompts","text":"<pre><code># Get by UUID\nprompt = store.get(\"prompt-uuid\")\n\n# Get specific version\nold_version = store.get(\"prompt-uuid\", version=1)\n\n# Search prompts\ncoding_prompts = store.find(\"code\", field=\"description\")\n</code></pre>"},{"location":"basic-usage/#using-prompts","title":"Using Prompts","text":"<pre><code># Fill a prompt template\nprompt = store.get(\"prompt-uuid\")\nresult = prompt.fill({\n    \"language\": \"Python\",\n    \"task\": \"sorts a list in ascending order\"\n})\n</code></pre> <p>Similarly, you can use prompts from an online source:</p> <pre><code>url = \"https://raw.githubusercontent.com/awesome-org/prompt-collections/main/prompts.json\"\n# Using a sample prompt collection hosted on GitHub.\n# Fill a prompt template\nprompt = store.get_online(\"prompt-uuid\", url)\nresult = prompt.fill({\n    \"language\": \"Python\",\n    \"task\": \"sorts a list in ascending order\"\n})\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install promptstore using pip:</p> <pre><code>pip install promptstore\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>Create a store and add some prompts:</p> <pre><code>from promptstore import PromptStore\n\n# Create a new store\nstore = PromptStore(\"./prompts\")\n\n# Add a prompt\nprompt = store.add(\n    content=\"Explain {{concept}} in simple terms\",\n    description=\"Simplification prompt\",\n    tags=[\"explanation\", \"simplification\"]\n)\n\n# Use the prompt\nexplanation = prompt.fill({\"concept\": \"quantum computing\"})\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Check out the User Guide for more detailed information about using PromptStore.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Jinja2</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":"pipuvDevelopment <pre><code>pip install promptstore\n</code></pre> <pre><code>uv pip install promptstore\n</code></pre> <pre><code>git clone https://github.com/lamalab/promptstore\ncd promptstore\nuv pip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>You can verify your installation by running:</p> <pre><code>from promptstore import PromptStore\nprint(PromptStore)  # Should print the class location\n</code></pre>"}]}